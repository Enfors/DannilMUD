* Technical design
** Conventions
*** Directories
Directories should have short, logical names that make them easy to
remember, and make paths short. All lowercase letters. Words are
separated with an underscore.

*** Files
All filenames (except README-files and the like) should consist of all
lowercase letters (as well as underscores and such as necessary).

Module file names start with "m_", followed by the module name.

*** Classes
Class names consist of a series of one or more words, where the first
letter of each word is capitalized. The rest of the letters are
lowercase. Example: UserManager

*** Objects
Object names consist of one or more all lowercase words, separated by
underscores. Example: user_manager

*** Functions
Function names consist of one or more all lowercase words, separated
by underscores. Example: send_message. Class functions that are
"private" - meant to only be called from within the object that
defines them - have a name beginning with an underscore. Only other
member functions in the same class are allowed to call such functions.

*** Variables
Variable names consist of one or more all lowercase words, separated
by underscores. Example: user_name

** File and module structure
** Code architecture
*** Overview
*** Code components
**** Startup
**** Network
**** Data storage
All objects that need to store data on secondary storage use a
dictionary for that data. DM implements the ability to save and load
this dictionary.

**** Command handling
**** Combat
**** NPC AI
**** Game daemons
***** Plant handling
***** Weather
*** The main loop
**** Terminology
| Term       | Description                                      |
|------------+--------------------------------------------------|
| Tick       | Each iteration of the main loop is called a tick |
| Heart beat | Function called in objects each tick             | 
  
**** Variables
| Variable        | Description                                    |
|-----------------+------------------------------------------------|
| tick_len        | How long between each tick (2000 milisec)      |
| num_heart_beats | Number of objects with registered heart_beats  |
| tick_start_time | The time when this tick started                |
| tick_end_time   | The time when this tick is supposed to be done |

**** Pseudocode
- Every tick (tick length = tick_len):
  - Store current_time() in tick_start_time
  - Set tick_end_time = tick_start_time + tick_len
  - Until all object ticks are handled:
    - While network traffic in queue:
      - Hande one traffic event
    - Handle 10 object heart beats
  - While current_time() is less than tick_end_time():
    - Wait for network traffic (timeout = tick_end_time - current_time())
*** Game objects
Game objects are objects that appear in the game, such as room,
weapons, characters, monsters, clothes, and so on.

**** Properties
All game objects have a set of properties, called props, stored in a
dictionary. Each prop has a name (key) and a value.

***** Weight
Weight is measured in units of 10 grams. So, one kilogram is 100.

***** Bulk
Bulk measures how "bulky" an object is, as in how much empty space
it needs in a bag in order to fit.

| Bulk | Example object         |
|------+------------------------|
|    1 | Acorn                  |
|    5 | Golf ball-sized stone  |
|   20 | Fist-sized stone       |
|   50 | Helmet                 |
|   80 | Short sword            |
|  100 | Short bow              |
|  120 | Long sword             |
|  140 | Long bow, breast plate |

**** The game object class tree
All game objects are objects of a class that inherits from a class in
the game object class tree (the GOCT, for short). The root of the GOCT
is the "object" class. Game object classes can inherit from any class
in the GOCT, not just the leaves.

A game object can never change which class in the GOCT that it
inherits from. Therefore, care must be taken when adding classes to
the GOCT so that an game object will never suffer because it can't
change its parent. For example, if the roof collapses in a house, that
room will change from being "indoors" to "outdoors". Since this is a
change that must be allowed, there can never be separate classes for
indoor and outdoor rooms. Instead, that should be controlled by an
attribute in the "room" class.

Likewise, a humanoid druid could conceivably transform himself into a
bear. Therefore, "humanoid" should not be a class in the GOCT.

***** Base

| Prop   | Description                             |
|--------+-----------------------------------------|
| bulk   | How bulky the object is                 |
| weight | How much it weighs (100 = 1 kg)         |
| short  | Short description, shown in environment |
| long   | Long description, shown when examined   | 
  
****** Container
| Prop       | Description                         |
|------------+-------------------------------------|
| bulk_cap   | How much bulk fits in the container |
| weight_cap | How much weight can it handle       |
  
******* Room
| Prop  | Description                                          |
|-------+------------------------------------------------------|
| exits | Dict of directions, pointing to destination rooms    |
| light | How light or dark it is. 10 = daylight, 0 = no light |

******* Body
| Prop | Description |
|------+-------------|
|      |             | 

******** User char
| Prop | Description |
|------+-------------|
|      |             | 

******** NPC
| Prop | Description |
|------+-------------|
|      |             | 

****** Equipment
| Prop | Description |
|------+-------------|
|      |             | 
  
******* Wearable
| Prop | Description |
|------+-------------|
|      |             | 

******** Armour
| Prop | Description |
|------+-------------|
|      |             | 

******** Clothing
| Prop | Description |
|------+-------------|
|      |             | 

******* Weapon
| Prop | Description |
|------+-------------|
|      |             | 

******** Ranged_weapon
| Prop | Description |
|------+-------------|
|      |             | 

******** Melee_weapon
| Prop | Description |
|------+-------------|
|      |             | 

***** Modules
Modules are files containing classes used to modify the nature of
an object. They are meant to be used with multiple inheritance, where
the first inheritance is the "proper" parent, and the module classes
are the consequtive parents.

For example, "sword" is a "proper" parent. So is "torch". The torch
uses the m_light_source module to provide the light. So, Torch uses
the Equipment class as its proper (first) parent, and LightSource as
its second parent.

Why can't Torch use LightSource as its proper (first) parent? Well, we
might want to have a magical sword at some point, which aside from
being a weapon is also a light source. So, this sword must have Sword
as its "proper" (first) parent - it can't have LightSource, or it
wouldn't be a sword. Therefore, LightSource is used as a module, being
inherited from as the second parent.

*** Events
Messages (plain text) needs to be transmitted between different game
objects to report in-game occurances. These occurances are called
events.

**** Event class hierarchy
- Evt
  - ComEvt (Communication Event)
    - SayEvt
    - EmoteEvt
    - TellEvt
  - ActionEvt
    - MoveEvt
      - EnterEvt
      - LeaveEvt
    - CombatEvt

**** The broadcast bool
The broadcast affects to whom the event is shown.

- Off: Only sent to the doer and target (if set).
- On: Broadcast to the rooms of the doer and the target.

*** Daemons
**** The update daemon
The update daemon's sole purpose in life is to make it possible to
update code while the game is running. Each time the driver needs an
(updatable) object - such as the command parser, for example - it
asks the update daemon for it. So, to update the command parser after
having changed the code, we ask the update daemon to reload it. Then,
the next time the driver asks the update daemon for the command parser,
the update daemon hands over the newest version of it.

***** A day in the life of the update daemon
1. Be initialized by the driver.
2. Wait for requests:
   1. If a request for an object arrives:
      1. If the object is not available in the cache, load it, cache
         it and return it.
      2. If the object is available in the cache, return it.
   2. If an update request arrives, reload the specified code
      and store a pointer to it in a cache.

**** The command parser
When the command parser initializes, it imports all commands in each
command directory except files named "base", and instantiates the Cmd
class in each of them.

There are different directories where commands reside.

| Directory  | Description                        |
|------------+------------------------------------|
| cmd/player | Commands available to all users    |
| cmd/wiz    | Commands available only to wizards |
| cmd/admin  | Commands available only to admins  |
  
***** Parsing algorithm
The parser works with two sets of data.

1. The input from a user, and
2. The parsing rules for each command.

****** Parsing rules
Parsing rules look like this:

- look
- look at OBJ
- give OBJ to LIV
- say STR

The words in capital letters (OBJ, LIV, STR) are tokens.

****** Tokens
******* OBJ
OBJ matches an object. It can have any of the following forms:

- (the) (Nth) (adjective) object_name

The words within parenthesis are optional, and can appear in any combination,
but only in that order.

******* LIV
LIV represents a living body. It will match anything in the environment
or within the user which is considered to be living.

******* STR
STR will match any arbitrary string, including spaces.

****** The algorithm
1. Find a command that matches the first word in the input.
2. Strip away the command from the input.
3. Foreach of that command's rules:
   1. Check if the rule matches the input.
      1. Foreach word (token / plain) in the rule:
	 1. Check if it matches the first part of the input.
	    1. If it matches, strip that part away and continue with the
	       next word in the rule.
	    2. If it doesn't match, then return; this rule doesn't match.
      2. Check if there is still input left.
	 1. If there is not, then the rule matches the input. Return
	    successfully.
	 2. If there is still input, then return failure; this rule doesn't
	    match the input.
4. Call the the function in the command that corresponds to the
   matching rule.
*** World
**** Rooms
***** Room coordinates, paths and file names
To identify and load a room, we need the following:
| Name      | Description                                              |
|-----------+----------------------------------------------------------|
| code_file | The file containing the code for the room (obj/dig_room) |
| area_path | The dir the rooms are saved in                           |
| coords    | The coordinates for the room                             |

These values are need:
1) When loading a room from disc. They are supplied as arguments 1, 2
   and 3, respectively.
2) When adding an exit, so the other room can be identified and
   loaded. They are supplied as arguments after the direction to the
   add_exit() function.



world.ooc.mansion.-1,-3,2
\-------+-------/ \--+--/
        |            |
    area_path      coords

**** Area creation
1. To create an area, first you create a directory for it (probably
   under the world directory).
2. Next step is to create the first room. This is done with the
   command "mkroom", which takes the area's path as an argument.
3. The newly created room saves its path. This is needed to create
   exits.
4. To create additional rooms, stand in the first room and type
   "dig DIR".

*** User logout
When a user logs out, the following needs to happen:

- User removed from room :: user_char.end() -> base.end()
- Stop polling :: con.end()
- User removed from who list
- Send "leave the game" event.
- Tell connection to close after write
- Wait for write to finish

**** Involved code sections
- user_char.end()
- user_man.end_user()
- con.end()
- quit()

**** Functions that need calling
- user_char.end()
  - 

**** Current procedure
Existing procedure:
- quit()
  - user_char.end()
    - body.end()
      - (fallthrough to super) base.end()
	- Remove user object from room
    - user_char.close_con()
      - con.end_after_write()
	- con.end()
	  - con._dont_watch_anything()
	  - con_man.end_con()
	    - delete sockets from watchlist
	    - delete con from cons list
	    - user_char.con_closed()
	      - user_man.end_user()
		- remove user from who list
		- #user_char.end() # <-- Recursion! Commented out.
	  - sock.shutdown()
	  - sock.close()
	- con.end_after_write = True
  - Send "left the game" to others

** Relationship between DannilMUD and HollowTreeMUD
I'm currently leaning towards not dividing the game into "driver" and
"mudlib". The advantage of the division would be that it would be
easier to make another game after HollowTreeMUD, but that's unlikely
to ever happen. The disadvantage would be that it would create an
artificial barrier in the code, with some parts of the code on one
side, and the rest of the code on the other side. That would make
coding more difficult.

Therefore, I'm marking the following subsections as obsolete.

*** DannilMUD (obsolete)
DannilMUD is the driver. It doesn't contain a game, just the ability
to make and run one. DannilMUD knows what rooms, characters, objects,
weapons etc are, but it doesn't contain any of them. It also has a
generic combat system that is not tied to any specific theme.

The driver needs a config file. This config file tells the driver
where to find the mudlib directory, among other things. If you change
this to point to another mudlib and restart the driver, a totally
different game will be loaded - different characters, different world,
and so on.

The driver contains code to handle rooms, inventory, messages and
such. It also provides some basic commands like "say", "go", and
"quit". The mudlib provides the rest of the commands.

**** Characters
***** Skill system
The driver contains the skill system, but no skills.

*** Hollow Tree MUD (obsolete)
Hollow Tree MUD is the game. It is referred to as a "mudlib", like in
LP-MUDs. It contains the actual rooms, fantasy weapons, spells, etc
that are part of the game.

The mudlib consists of a directory. Inside it, is a file called
config.txt. It contains the name of the game, and the port number to
listen to (among other things).

Since the driver only provides a very limited array of commands, it is
up the mudlib to provide the rest.

*** TODO Draw line between driver and lib (obsolete)
Where do I draw the line between driver and lib when it comes to
skills? Are all skills in the lib, and just the skill system in the
driver? Probably, yes.


* Game design
** Characters
*** Stats
Stats are intrinsic values that all characters have. They are
different from skills in that skills are something you learn.

Stat values range from 0 and upwards without a set maximum. The
typical average value for a humanoid is 10.

**** Agility
How "flexible" the character's body is. Not sure if I want to keep
this stat thought. I'm not sure if any significan amount of skills
would be connected to it.

**** Dexterity
"Body skill", so to speak; determines how skilled the character is in
using his body in various ways.

**** Endurance
Determines how long the character can perform manual labor without
becoming exhausted.

**** Constitution
Determines how much damage a character can take without dying.

**** Strength
Determines how strong the character is.

**** Perception
Determines the character's ability to preceive things in his
surroundings.

**** Focus
Determines the character's ability to concentrate.

**** Intelligence
How intelligen the character is.

**** Wisdom
Determines how much the character knows. Due to the fact that I'm
planning to implement a knowledge system that keeps track of exactly
what a character knows, it's bebatable whether or not to keep this
stat. But the knowledge system can't possibly contain everything, so I
might keep this stat anyway.
     
*** Skills
Skill values range from 0 (don't have the skill) to a maximum of 20.

**** Skill roll (sr) and mofidiers
When a skill roll is made, a modifier is used. The modifier represents
the difficulty of this particular task. A positive modifier meas that
the task is relatively easy, while a negative modifier means that the
task is relatively difficult. To make a skill roll, roll 3d6. If the
result is lower than or equal to the character's skill value plus the
modifier (which is typically between -10 and +10), then the roll was a
sucess. In other words:

 - result = skill value + modifier - 3d6

If result is a positive number or zero, the skill roll succeeds by
that many points. Otherwise, it fails.

**** Skill costs
| Stat | Very easy | Easy | Average | Hard | Very hard |
|------+-----------+------+---------+------+-----------|
|   -6 |           |      |         |      |         1 |
|   -5 |           |      |         |    1 |         1 |
|   -4 |           |      |       1 |    1 |         2 |
|   -3 |           |    1 |       1 |    2 |         2 |
|   -2 |         1 |    1 |       2 |    2 |         2 |
|   -1 |         1 |    2 |       2 |    2 |         3 |
|    0 |         2 |    2 |       2 |    3 |         3 |
|   +1 |         2 |    2 |       3 |    3 |         4 |
|   +2 |         2 |    3 |       3 |    4 |         5 |
|   +3 |         3 |    3 |       4 |    5 |         6 |
|   +4 |         3 |    4 |       5 |    6 |         8 |
|   +5 |         4 |    5 |       6 |    8 |        10 |
|   +6 |         5 |    6 |       8 |   10 |        13 |
|   +7 |         6 |    8 |      10 |   13 |        17 |

** Combat
*** Bodies
**** Humanoid
****** Humanoid body configuration

           Head
            10%
             |
Right arm--Chest--Left arm
   10%      40%     10%
           /   \
  Right leg     Left leg
     15%           15%

The default target is always the chest, unless the attacker specifies
otherwise. If the attack misses its indended target, there's a chance
that it might hit another body part. To determine this, the
percentages of all other body parts are assembled into a table. Let's
say an attack aimed at the chest misses. Then, a table like this will
be assembled:

| Body part | Min | Max |
|-----------+-----+-----|
| Head      |   1 |  10 |
| Right arm |  11 |  20 |
| Left arm  |  21 |  30 |
| Right leg |  31 |  44 |
| Left leg  |  45 |  60 |
| Miss      |  61 | 100 |

A d100 is used to determine which body part is hit, if any.

However, the chest is a special case since it is "adjacent" to all
other body parts. If the body part is "further" away than that, it's
chance of being hit is halved (round downards) for each successive
"step". So if you aim at the head and miss, there's a 40% chance of
hitting the chest instead, but only a 7% chance (half of 15%) of
hitting the left leg.

*** Formulas
*** Missile weapon accuracy (accuracy)
- Result = sr + accuracy + target's size - 10

** Ideas
*** Sizes
| Size | Description                 | Animal                    |
|------+-----------------------------+---------------------------|
|    1 | Coin                        | Beetle, fly               |
|    2 | Fist-sized object, A4 paper | Squirrel, rat, small bird |
|    3 | Shortsword, book            | Rabbit                    |
|    4 | Longsword, shield           | Cat, large bird           |
|    5 | Dog                         | Dog, sheep, deer          |
|    6 | Dwarf                       | Wolf                      |
|    7 | Human                       | Pony, human               |
|    8 | Orc                         | Cow                       |
|    9 | Horse, bear                 | Horse, bear               |
|------+-----------------------------+---------------------------|
